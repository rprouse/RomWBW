;==============================================================================
; DEVIVE INVENTORY - Inventory Device
; Version  August-2025
;==============================================================================
;
; This was extracted from HBIOS and converted into a ROM Application
;
; This is a program CALLED from RomLoader, and is specific to RomWBW
;------------------------------------------------------------------------------
;
; Change Log:
;   2025-06-30 [MAP] Initial Release copied from HBIOS.ASM
;   2025-08-09 [WBW] Add support for ESPSD driver
;______________________________________________________________________________
;
; Include Files
;
#include "std.asm"	; standard RomWBW constants
;
;*****************************************************************************
;
; APPLICATION WILL WILL BE LOADED AT DEV_LOC.  THEREFORE, THE CODE
; MUST "ORG" AT THIS ADDRESS.  TO CHANGE THE LOAD LOCATION OF THIS
; CODE, YOU CAN UPDATE DEV_LOC IN LAYOUT.INC
;
	.ORG	DEV_LOC
;
;*****************************************************************************
; INIT CODE
;*****************************************************************************
;
;
;*****************************************************************************
; Main Code starts here
;*****************************************************************************
;
PRTSUM:
	CALL	NEWLINE2		; SKIP A LINE
	LD	DE,PS_STRHDR		; POINT TO HEADER
	CALL	WRITESTR		; PRINT IT
;
	LD	C,BF_SYSGET_CIOCNT	; CHARACTER DEVICES
	LD	HL,PS_SERIAL
	CALL	PRT_ALLD
;
	LD	C,BF_SYSGET_DIOCNT	; DISK DRIVES
	LD	HL,PS_DISK
	CALL	PRT_ALLD
;
	LD	C,BF_SYSGET_VDACNT	; VIDEO DEVICES
	LD	HL,PS_VIDEO
	CALL	PRT_ALLD
;
	LD	C,BF_SYSGET_SNDCNT	; SOUND DEVICES
	LD	HL,PS_SOUND
	CALL	PRT_ALLD
	RET
;
;*****************************************************************************
; Supporting Code Stars Here
;*****************************************************************************
;
PRT_ALLD:
	LD	B,BF_SYSGET		; FUNC: SYSTEM INFO GET
	RST	08			; E := UNIT COUNT
	LD	B,E			; MOVE TO B FOR LOOP COUNT
	LD	A,E			; MOVE TO ACCUM
	OR	A			; SET FLAGS
	RET	Z			; IF NONE, JUST RETURN
	LD	C,0			; C WILL BE UNIT INDEX
PRT_ALLD1:
	PUSH	BC			; SAVE LOOP CONTROL
	PUSH	DE
	PUSH	HL
	CALL	JPHL			; CALL THE ROUTINE PASSED IN HL
	POP	HL
	POP	DE
	POP	BC			; RESTORE LOOP CONTROL
	INC	C			; BUMP UNIT INDEX
	DJNZ	PRT_ALLD1		; LOOP THRU ALL DEVICES
	RET
;
; PRINT ONE LINE DISK UNIT/DEVICE INFO, DISK UNIT INDEX IN C
;
PS_DISK:
	PUSH	BC			; SAVE UNIT INDEX FOR LATER
;
	; UNIT COLUMN
	PRTS("Disk $")
	LD	A,C			; MOVE UNIT NUM TO A
	CALL	PRTDECB			; PRINT IT
	CP	10			; CHECK FOR MULTIPLE DIGITS
	CALL	C,PC_SPACE		; EXTRA SPACE IF NEEDED
	PRTS("     $")			; PAD TO NEXT COLUMN
;
	; DEVICE COLUMN
	LD	B,BF_DIODEVICE		; FUNC=GET DEVICE INFO, UNIT NUM STILL IN C
	RST	08			; DE:=DEVTYP/NUM, C:=DISK ATTRIBUTES
	PUSH	BC			; SAVE ATTRIBUTES
	LD	HL,PS_DDMD		; POINT TO DISK DEVICE TYPE NAME TABLE
	CALL	PS_PRTDEV		; PRINT DISK DEVICE NMEMONIC PADDED TO FIELD WIDTH
	POP	DE			; RECOVER ATTRIBUTES TO DE
	PUSH	DE			; SAVE ATTRIBUTES AGAIN
	CALL	PS_PRTDT		; PRINT DISK TYPE
	POP	DE			; RESTORE ATTRIBUTES
	POP	BC			; RESTORE UNIT NUM
	CALL	PS_PRTDC		; PRINT DISK CAPACITY
;
	CALL	NEWLINE
	RET
;
; PRINT DISK TYPE (DISK ATTRIBUTE IN E)
;
PS_PRTDT:
	LD	A,E			; ATTRIBUTES TO A
	BIT	7,A			; FLOPPY BIT SET?
	LD	HL,PS_DTFLOP		; ASSUME FLOPPY
	JP	NZ,PS_PRT18		; IF FLOPPY, JUMP AHEAD
	LD	C,E
	LD	DE,PS_DTHARD
	LD	A,00001111B
	CALL	PRTIDXMSK
	CALL	PS_PAD18		; PAD TO 18 SPACES
	RET
;
; PRINT DISK CAPACITY (UNIT IN C, ATTRIBUTE IN E)
;
PS_PRTDC:
;
	LD	A,E			; ATTRIBUTE TO ACCUM
	BIT	7,A			; TEST FOR FLOPPY
	JR	NZ,PS_PRTDC2		; HANDLE FLOPPY
	AND	$0F			; ISOLATE TYPE BITS
	CP	4			; ROM DISK?
	JR	Z,PS_PRTDC1		; PRINT CAPACITY IN KB
	CP	5			; RAM DISK?
	JR	Z,PS_PRTDC1		; PRINT CAPACITY IN KB
	CP	7			; FLASH DISK?
	JR	Z,PS_PRTDC1		; PRINT CAPACITY IN KB
;
	; PRINT HARD DISK STORAGE SIZE IN MB
	LD	B,BF_DIOCAP		; HBIOS FUNC: GET CAPACTIY
	RST	08			; DE:HL := BLOCKS
	JP	NZ,PS_PRTNUL		; MEDIA PROBLEM
	RES	7,D			; CLEAR LBA BIT
	LD	B,11			; 11 BIT SHIFT TO CONVERT BLOCKS --> MB
	CALL	SRL32			; RIGHT SHIFT
	CALL	PRTDEC32		; PRINT DWORD IN DECIMAL
	PRTS("MB$")			; PRINT SUFFIX
	CALL	PC_COMMA
	PRTS("LBA$")			; FOR NOW, WE ASSUME HARD DISK DOES LBA
	RET				; DONE
;
PS_PRTDC1:
	; PRINT ROM/RAM DISK CAPACITY IN KB
	LD	B,BF_DIOCAP		; HBIOS FUNC: GET CAPACTIY
	RST	08			; DE:HL := BLOCKS
	JP	NZ,PS_PRTNUL		; MEDIA PROBLEM
	RES	7,D			; CLEAR LBA BIT
	LD	B,1			; 11 BIT SHIFT TO CONVERT BLOCKS --> MB
	CALL	SRL32			; RIGHT SHIFT
	CALL	PRTDEC32		; PRINT DWORD IN DECIMAL
	PRTS("KB$")			; PRINT SUFFIX
	CALL	PC_COMMA
	PRTS("LBA$")			; FOR NOW, WE ASSUME HARD DISK DOES LBA
	RET				; DONE
;
PS_PRTDC2:
	LD	C,E			; ATTRIBUTE TO C FOR SAFE KEEPING
;
	LD	A,%00011000		; DISPLAY FORM FACTOR
	LD	DE,PS_FLP_FSTR		; WHICH IS DEFINED IN
	CALL	PRTIDXMSK		; BITS 5 AND 6.
;
	LD	A,%00000100		; DISPLAY SIDES
	LD	DE,PS_FLP_SSTR		; WHICH IS DEFINED
	CALL	PRTIDXMSK		; IN BIT 4
;
	LD	A,%00000011		; DISPLAY DENSITY
	LD	DE,PS_FLP_DSTR		; WHICH IS DEFINED IN
	CALL	PRTIDXMSK		; BITS 2 AND 3.
;
	CALL	PC_COMMA
	PRTS("CHS$")			; FOR NOW, WE ASSUME HARD DISK DOES LBA
;
	RET				; DONE
;
; PRINT ONE LINE SERIAL UNIT/DEVICE INFO, SERIAL UNIT INDEX IN C
;
PS_SERIAL:
	PUSH	BC			; SAVE UNIT INDEX FOR LATER
;
	; UNIT COLUMN
	PRTS("Char $")
	LD	A,C			; MOVE UNIT NUM TO A
	CALL	PRTDECB			; PRINT IT, ASSUME SINGLE DIGIT
	PRTS("      $")			; PAD TO NEXT COLUMN
;
	; DEVICE COLUMN
	LD	B,BF_CIODEVICE		; FUNC=GET DEVICE INFO, UNIT NUM STILL IN C
	RST	08			; DE:=DEVTYP/NUM, C:=DEVICE ATTRIBUTES
	PUSH	BC			; SAVE ATTRIBUTES
	LD	HL,PS_SDUART		; POINT TO SERIAL DEVICE TYPE NAME TABLE
	CALL	PS_PRTDEV		; PRINT SERIAL DEVICE NMEMONIC PADDED TO FIELD WIDTH
	POP	BC			; RECOVER ATTRIBUTES
	PUSH	BC			; SAVE ATTRIBUTES AGAIN
	CALL	PS_PRTST		; PRINT SERIAL TYPE
	POP	BC			; RESTORE ATTRIBUTES
	POP	DE			; RESTORE UNIT NUM TO E
	CALL	PS_PRTSC		; PRINT SERIAL CONFIG
;
	CALL	NEWLINE
	RET
;
; PRINT CHARACTER TYPE (SERIAL ATTRIBUTE IN C)
;
PS_PRTST:
	LD	HL,PS_STPPT
	BIT	6,C
	JP	NZ,PS_PRT18		; PARALLEL TYPE?
	LD	HL,PS_STRS232		; ASSUME RS-232
	BIT	7,C			; 0=RS-232, 1=TERMINAL
	JP	Z,PS_PRT18		; HANDLE TERMINAL TYPE
	LD	HL,PS_STTERM		; TYPE IS TERMINAL
	JP	PS_PRT18
;
; PRINT SERIAL CONFIG (UNIT IN E, ATTRIBUTE IN C)
;
PS_PRTSC:
	BIT	6,C			; PARALLEL TYPE?
	JR	NZ,PSPRTPC0

	BIT	7,C			; 0=RS-232, 1=TERMINAL
	JP	NZ,PS_PRTSC1		; PRINT TERMINAL CONFIG
;
	; PRINT RS-232 CONFIG
	LD	B,BF_CIOQUERY		; HBIOS FUNC: GET CIO CONFIG
	LD	C,E			; SET SERIAL UNIT NUM
	RST	08			; DE:HL := BAUD RATE
	LD	A,D			; TEST FOR $FF
	AND	E
	INC	A			; SET Z IF DE == $FF
	JP	Z,PS_PRTNUL		; $FF == NO CONFIG DEFINED
;
PS_PRTSC0:
	; PRINT BAUD RATE
	PUSH	DE			; PRESERVE DE
	LD	A,D
	AND	$1F			; ISOLATE ENCODED BAUD RATE
	LD	L,A			; PUT IN L
	LD	H,0			; H IS ALWAYS ZERO
	LD	DE,75			; BAUD RATE DECODE CONSTANT
	CALL	DECODE			; DE:HL := BAUD RATE
	LD	BC,HB_BCDTMP		; POINT TO TEMP BCD BUF
	CALL	BIN2BCD			; CONVERT TO BCD
	CALL	PRTBCD			; AND PRINT IN DECIMAL
	POP	DE			; RESTORE DE
;
	; PRINT DATA BITS
	PUSH	DE			; PRESERVE DE
	CALL	PC_COMMA		; FORMATTING
	LD	A,E			; GET CONFIG BYTE
	AND	$03			; ISOLATE DATA BITS VALUE
	ADD	A,'5'			; CONVERT TO CHARACTER
	CALL	COUT			; AND PRINT
	POP	DE			; RESTORE DE
;
	; PRINT PARITY
	PUSH	DE			; PRESERVE DE
	CALL	PC_COMMA		; FORMATTING
	LD	A,E			; GET CONFIG BYTE
	RRCA				; SHIFT RELEVANT BITS
	RRCA				; ...
	RRCA				; ...
	AND	$07			; AND ISOLATE DATA BITS VALUE
	LD	HL,PS_STPARMAP		; CHARACTER LOOKUP TABLE
	CALL	ADDHLA			; APPLY OFFSET
	LD	A,(HL)			; GET CHARACTER
	CALL	COUT			; AND PRINT
	POP	DE			; RESTORE DE
;
	; PRINT STOP BITS
	CALL	PC_COMMA		; FORMATTING
	LD	A,E			; GET CONFIG BYTE
	RRCA				; SHIFT RELEVANT BITS
	RRCA				; ...
	AND	$01			; AND ISOLATE DATA BITS VALUE
	ADD	A,'1'			; MAKE IT A CHARACTER
	CALL	COUT			; AND PRINT
;
	RET
;
PSPRTPC0:
	LD	B,BF_CIOQUERY		; HBIOS FUNC: GET CIO CONFIG
	LD	C,E			; SET PARALLEL UNIT NUM
	RST	08			; DE:HL := I/O SETTING
	LD	A,D			; TEST FOR $FF
	AND	E
	INC	A			; SET Z IF DE == $FF
	JP	Z,PS_PRTNUL		; $FF == NO CONFIG DEFINED
;
PS_PRTPC0:
	LD	C,E			; DISPLAY PIO TYPE
	LD	A,11000000B		; WHICH IS DEFINE BY
	LD	DE,PIO_MODE_STR		; BITS 6 AND 7
	JP	PRTIDXMSK
;	RET				; TRICK RETURN
;
PS_PRTSC1:
	; PRINT TERMINAL CONFIG
	LD	A,C			; GET ATTRIBUTE VALUE
	CP	$BF			; NO ATTACHED VDA
	JR	Z,PS_PRTSC2
	PRTS("Video $")			; FORMATTING
	AND	$0F			; ISOLATE VIDEO UNIT NUM
	CALL	PRTDECB			; PRINT IT
	CALL	PC_COMMA
#IF (VDAEMU == EMUTYP_TTY)
	PRTS("TTY$")
#ENDIF
#IF (VDAEMU == EMUTYP_ANSI)
	PRTS("ANSI$")
#ENDIF
	RET
;
PS_PRTSC2:
	PRTS("Term Module$")
	CALL	PC_COMMA
	PRTS("ANSI$")
	RET
;
; PRINT ONE LINE VIDEO UNIT/DEVICE INFO, VIDEO UNIT INDEX IN C
;
PS_VIDEO:
	PUSH	BC			; SAVE UNIT INDEX FOR LATER
;
	; UNIT COLUMN
	PRTS("Video $")
	LD	A,C			; MOVE UNIT NUM TO A
	CALL	PRTDECB			; PRINT IT, ASSUME SINGLE DIGIT
	PRTS("     $")			; PAD TO NEXT COLUMN
;
	; DEVICE COLUMN
	LD	B,BF_VDADEV		; FUNC=GET DEVICE INFO, UNIT NUM STILL IN C
	RST	08			; DE:=DEVTYP/NUM, H:=DISK ATTRIBUTES
	PUSH	BC			; SAVE ATTRIBUTES
	LD	HL,PS_VDVDU		; POINT TO VIDEO DEVICE TYPE NAME TABLE
	CALL	PS_PRTDEV		; PRINT VIDEO DEVICE NMEMONIC PADDED TO FIELD WIDTH
	POP	DE			; RECOVER ATTRIBUTES
	PUSH	DE			; SAVE ATTRIBUTES AGAIN
	CALL	PS_PRTVT		; PRINT VIDEO TYPE
	POP	DE			; RESTORE ATTRIBUTES
	POP	BC			; RESTORE UNIT NUM
	CALL	PS_PRTVC		; PRINT VIDEO CONFIG
;
	CALL	NEWLINE
	RET
;
; PRINT VIDEO TYPE (VIDEO ATTRIBUTE IN E)
;
PS_PRTVT:
	LD	HL,PS_VTCRT		; ASSUME CRT
	JP	PS_PRT18		; PRINT
;
; PRINT VIDEO CONFIG (UNIT IN C, ATTRIBUTE IN E)
;
PS_PRTVC:
	PRTS("Text$")
	CALL	PC_COMMA
	LD	B,BF_VDAQRY		; FUNC: QUERY FOR VDA CONFIG
	RST	08			; D:=ROWS, E:=COLS
	LD	A,E
	CALL	PRTDECB
	LD	A,'x'
	CALL	COUT
	LD	A,D
	CALL	PRTDECB
	RET
;
; PRINT SOUND CONFIG
;
PS_SOUND:
	PUSH	BC

	; UNIT COLUMN
	PRTS("Sound $")
	LD	A,C			; MOVE UNIT NUM TO A
	CALL	PRTDECB			; PRINT IT
	CP	10			; CHECK FOR MULTIPLE DIGITS
	CALL	C,PC_SPACE		; EXTRA SPACE IF NEEDED
	PRTS("    $")			; PAD TO NEXT COLUMN

	; DEVICE COLUMN

	PUSH	BC
	LD	E,C
	XOR	A
	LD	DE,PS_SDSND		; POINT TO DEVICE TYPE NAME TABLE
	CALL	PRTIDXDEA		; PRINT  DEVICE NMEMONIC PADDED TO FIELD WIDTH
	LD	A,C			; MOVE UNIT NUM TO A
	CALL	PRTDECB			; PRINT IT
	CALL	PC_COLON
	LD	A,(PRTIDXCNT)
	SUB	12-1			; SUBTRACT FIELD WIDTH (LESS THE COLON)
	NEG				; MAKE IT A POSITIVE NUMBER
	CALL	PS_PAD			; PAD AS NEEDED
	POP	BC

	; DEVICE TYPE
;
	LD	B,BF_SNDQUERY		; FUNC=GET DEVICE INFO, UNIT NUM STILL IN C
	LD	E,BF_SNDQ_DEV
	RST	08
	PUSH	BC
	LD	A,B
	LD	DE,PS_SDSN76489
	CALL	PRTIDXDEA
	CALL	PS_PAD18
	POP	BC
;
	; DEVICE CHARACTERISTICS
;
	LD	B,BF_SNDQUERY		; FUNC=GET DEVICE INFO, UNIT NUM STILL IN C
	LD	E,BF_SNDQ_CHCNT
	RST	08
	LD	A,B
	CALL	PRTDECB
	LD	A,'+'
	CALL	COUT
	LD	A,C
	CALL	PRTDECB
	PRTS(" CHANNELS$")
	CALL	NEWLINE
;
	POP	BC
	RET
;
; PRINT DEVICE NMEMONIC, DEVTYP/NUM SPECIFIED IN DE
;
PS_PRTDEV:
	EX	DE,HL
	LD	A,H			; TYPE ID
	CALL	PRTIDXDEA		; PRINT TYPE LABEL
	LD	A,L			; UNIT NUMBER
	CALL	PRTDECB			; PRINT NUM, ASSUME 1 CHAR
	CALL	PC_COLON		; PRINT COLON
	LD 	A,(PRTIDXCNT)
	SUB	12-2+1			; 12 CHAR FIELD - 1 POS FOR UNIT NUM AND 1 POS FOR COLON
	NEG
	CALL	PS_PAD			; PAD N SPACES (SPECIFIED IN A)
	RET
;
; PRINT DEVICE MNEMONIC, DEVTYP/NUM SPECIFIED IN DE
;
PS_PRTNUL:
	LD	HL,PS_STRNUL
	; FALL THRU TO PS_PRT
;
; PRINT STRING AT (HL), $ TERM, RETURN CHARS PRINTED IN C
;
PS_PRT:	LD	C,0			; INIT CHAR COUNT
PS_PRT1:
	LD	A,(HL)			; GET CHAR
	INC	HL			; BUMP INDEX
	CP	'$'			; TERM?
	RET	Z			; IF SO, DONE
	CALL	COUT			; PRINT IT
	INC	C			; BUMP COUNTER
	JR	PS_PRT1			; AND LOOP
;
; PAD 18 CHARACTER FIELD
;
PS_PAD18:
	LD	A,(PRTIDXCNT)
	LD	C,A
	JR	PS_PRT18A
;
; PRINT STRING AT HL IN 18 CHARACTER FIELD
;
PS_PRT18:
	CALL	PS_PRT			; PRINT $ TERM STRING AT (HL), C:=CHARS PRINTED
PS_PRT18A:
	LD	A,18			; 18 CHAR FIELD
	SUB	C
;	CALL	PS_PAD			; PAD N SPACES (SPECIFIED IN A)
;
; PAD N SPACES SPECIFIED IN A
;
PS_PAD:	LD	B,A
	LD	A,' '
PS_PAD1:
	CALL	COUT
	DJNZ	PS_PAD1
	RET
;
;*****************************************************************************
; Support Routines
;*****************************************************************************
;
; TODO Ideally we wouldnt import all these here, as they take up quite a
; bit of space. Util.asm needs to be broken up, or copy required code here
;
#include	"util.asm"
#include 	"decode.asm"
#include	"bcd.asm"
;
;=======================================================================
; Console character I/O helper routines (registers preserved)
;=======================================================================
;
#if (BIOS == BIOS_WBW)
;
; Output character from A
;
COUT:
	; Save all incoming registers
	push	af
	push	bc
	push	de
	push	hl
;
	; Output character to console via HBIOS
	ld	e,a			; output char to E
	ld	c,CIO_CONSOLE		; output to current HBIOS console
	ld	b,BF_CIOOUT		; HBIOS func: output char
	rst	08			; HBIOS outputs character
;
	; Restore all registers
	pop	hl
	pop	de
	pop	bc
	pop	af
	ret
;
#endif
;
#if (BIOS == BIOS_UNA)
;
; Output character from A
;
COUT:
	; Save all incoming registers
	push	af
	push	bc
	push	de
	push	hl
;
	; Output character to console via UBIOS
	ld	e,a
	ld	bc,$12
	rst	08
;
	; Restore all registers
	pop	hl
	pop	de
	pop	bc
	pop	af
	ret
;
#endif
;
;===============================================================================
; Static Strings and Data
;===============================================================================
;
PS_STRNUL	.TEXT	"--$"		; DISPLAY STRING FOR NUL VALUE
;
; DISK DEVICE STRINGS
;
PS_DDMD		.TEXT	"MD$"
PS_DDFD		.TEXT	"FD$"
PS_DDRF		.TEXT	"RF$"
PS_DDIDE	.TEXT	"IDE$"
PS_DDATAPI	.TEXT	"ATAPI$"
PS_DDPPIDE	.TEXT	"PPIDE$"
PS_DDSD		.TEXT	"SD$"
PS_DDPRPSD	.TEXT	"PRPSD$"
PS_DDPPPSD	.TEXT	"PPPSD$"
PS_DDHDSK	.TEXT	"HDSK$"
PS_DDPPA	.TEXT	"PPA$"
PS_DDIMM	.TEXT	"IMM$"
PS_DDSYQ	.TEXT	"SYQ$"
PS_DDCHUSB	.TEXT	"CHUSB$"
PS_DDCHSD	.TEXT	"CHSD$"
PS_DDCHNATUSB	.TEXT	"USB$"
PS_DDESPSD	.TEXT	"ESPSD$"
;
; DISK TYPE STRINGS
;
PS_DTFLOP	.TEXT	"Floppy Disk$"
PS_DTHARD	.TEXT	"Hard Disk$"
PS_DTCF		.TEXT	"CompactFlash$"
PS_DTSD		.TEXT	"SD Card$"
PS_DTUSB	.TEXT	"USB Drive$"
PS_DTROM	.TEXT	"ROM Disk$"
PS_DTRAM	.TEXT	"RAM Disk$"
PS_DTFSH	.TEXT	"Flash ROM$"
PS_DTRF		.TEXT	"RAM Floppy$"
PS_DTCD		.TEXT	"CD-ROM$"
PS_DTCRT	.TEXT	"Cartridge$"
PS_DTOUSBSCI	.TEXT	"SCSI$"
PS_DTOUSBUFI	.TEXT	"UFI$"
PS_DTOTHER	.TEXT	"???$"

;
; FLOPPY ATTRIBUTE STRINGS
;
PS_FLP_FSTR:	.TEXT	"8\",$"		; PS_FLP8
		.TEXT	"5.25\",$"	; PS_FLP5
		.TEXT	"3.5\",$"	; PS_FLP3
		.TEXT	"???\",$"	; PS_FLPN
;
PS_FLP_SSTR:	.TEXT	"SS/$"		; PS_FLPSS
		.TEXT	"DS/$"		; PS_FLPDS
;
PS_FLP_DSTR:	.TEXT	"SD$"		; PS_FLPSD
		.TEXT	"DD$"		; PS_FLPDD
		.TEXT	"HD$"		; PS_FLPHD
		.TEXT	"ED$"		; PS_FLPED
;
; CHARACTER DEVICE STRINGS
;
PS_SDUART	.TEXT	"UART$"
PS_SDASCI	.TEXT	"ASCI$"
PS_SDTERM	.TEXT	"TERM$"
PS_SDPRPCON	.TEXT	"PRPCON$"
PS_SDPPPCON	.TEXT	"PPPCON$"
PS_SDSIO	.TEXT	"SIO$"
PS_SDACIA	.TEXT	"ACIA$"
PS_SDPIO	.TEXT	"PIO$"
PS_SDUF		.TEXT	"UF$"
PS_SDDUART	.TEXT	"DUART$"
PS_SDZ2U	.TEXT	"Z2U$"
PS_SDLPT	.TEXT	"LPT$"
PS_SDESPCON	.TEXT	"ESPCON$"
PS_SDESPSER	.TEXT	"ESPSER$"
PS_SDSCON	.TEXT	"SCON$"
PS_SDSSER	.TEXT	"SSER$"
PS_SDEZ80	.TEXT	"EZ80$"
PS_SDPLDSER	.TEXT	"PLDSER$"
PS_SDTSER	.TEXT	"TSER$"
PS_SDSCC	.TEXT	"SCC$"
;
; CHARACTER SUB TYPE STRINGS
;
PS_STRS232	.TEXT	"RS-232$"
PS_STTERM	.TEXT	"Terminal$"
PS_STPPT	.TEXT	"Parallel$"
;
PS_STPARMAP	.DB	"NONENMNS"
;
; PARALLEL TYPE STRINGS
;
PIO_MODE_STR:	.TEXT	"Output$"
		.TEXT	"Input$"
		.TEXT	"Bidirectional$"
		.TEXT	"BitCtrl$"
;
; VIDEO DEVICE STRINGS
;
PS_VDVDU	.TEXT	"VDU$"
PS_VDCVDU	.TEXT	"CVDU$"
PS_VDGDC	.TEXT	"GDC$"
PS_VDTMS	.TEXT	"TMS$"
PS_VDVGA	.TEXT	"VGA$"
PS_VDVRC	.TEXT	"VRC$"
PS_VDEF		.TEXT	"EF$"
PS_VDFV		.TEXT	"FV$"
PS_VDXOSERA	.TEXT	"XOSERA$"
;
; VIDEO TYPE STRINGS
;
PS_VTCRT	.TEXT	"CRT$"
;
; SOUND DEVICE STRINGS
;
PS_SDSND	.TEXT	"SND$"
;
; SOUND TYPE STRINGS
;
PS_SDSN76489	.TEXT	"SN76489$"
PS_SDAY38910	.TEXT	"AY-3-8910$"
PS_SDBITMODE	.TEXT	"I/O PORT$"
PS_SDYM2612	.TEXT	"YM2612$"
;
;			 0	   1	     2	       3	 4	   5	     6	       7
;			 01234567890123456789012345678901234567890123456789012345678901234567890123456789
PS_STRHDR	.TEXT	"Unit        Device      Type              Capacity/Mode\r\n"
		.TEXT	"----------  ----------  ----------------  --------------------\r\n$"
;
;===============================================================================
; Working data
;===============================================================================
;
HB_BCDTMP	.FILL	5,0		; BCD NUMBER STORAGE (TEMP)
;
;===============================================================================
;
; IT IS CRITICAL THAT THE FINAL BINARY BE EXACTLY DEV_SIZ BYTES.
; THIS GENERATES FILLER AS NEEDED.  IT WILL ALSO FORCE AN ASSEMBLY
; ERROR IF THE SIZE EXCEEDS THE SPACE ALLOCATED.
;
SLACK	.EQU	(DEV_END - $)
;
#IF (SLACK < 0)
	.ECHO	"*** INVENTORY SLICE IS TOO BIG!!!\n"
	!!!	; FORCE AN ASSEMBLY ERROR
#ENDIF
;
	.FILL	SLACK,$00
	.ECHO	"INVNTDEV Device Inventory space remaining: "
	.ECHO	SLACK
	.ECHO	" bytes.\n"
;
;===============================================================================
;
.END
